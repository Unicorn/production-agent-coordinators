{
  "files": [
    {
      "path": "package.json",
      "operation": "create",
      "content": "{\n  \"name\": \"@test/logger\",\n  \"version\": \"1.0.0\",\n  \"description\": \"Simple typed logger utility\",\n  \"type\": \"module\",\n  \"exports\": {\n    \".\": {\n      \"types\": \"./dist/index.d.ts\",\n      \"import\": \"./dist/index.js\"\n    }\n  },\n  \"scripts\": {\n    \"build\": \"tsc\",\n    \"test\": \"vitest run --coverage\",\n    \"test:watch\": \"vitest\"\n  },\n  \"devDependencies\": {\n    \"@types/node\": \"^20.0.0\",\n    \"typescript\": \"^5.0.0\",\n    \"vitest\": \"^1.0.0\",\n    \"@vitest/coverage-v8\": \"^1.0.0\"\n  },\n  \"engines\": {\n    \"node\": \">=18.0.0\"\n  }\n}"
    },
    {
      "path": "tsconfig.json",
      "operation": "create",
      "content": "{\n  \"extends\": \"../../../tsconfig.json\",\n  \"compilerOptions\": {\n    \"outDir\": \"./dist\",\n    \"rootDir\": \"./src\",\n    \"strict\": true,\n    \"declaration\": true,\n    \"declarationMap\": true,\n    \"sourceMap\": true\n  },\n  \"include\": [\"src/**/*\"],\n  \"exclude\": [\"node_modules\", \"dist\", \"tests\"]\n}"
    },
    {
      "path": "src/types.ts",
      "operation": "create",
      "content": "/**\n * Log level type\n */\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error';\n\n/**\n * Logger configuration options\n */\nexport interface LoggerOptions {\n  /** Minimum log level to output */\n  level: LogLevel;\n  /** Whether to include timestamps in output */\n  timestamp?: boolean;\n}\n\n/**\n * Logger interface\n */\nexport interface Logger {\n  /**\n   * Log a debug message\n   */\n  debug(message: string, ...args: unknown[]): void;\n\n  /**\n   * Log an info message\n   */\n  info(message: string, ...args: unknown[]): void;\n\n  /**\n   * Log a warning message\n   */\n  warn(message: string, ...args: unknown[]): void;\n\n  /**\n   * Log an error message\n   */\n  error(message: string, error?: Error, ...args: unknown[]): void;\n}\n"
    },
    {
      "path": "src/logger.ts",
      "operation": "create",
      "content": "import type { Logger, LoggerOptions, LogLevel } from './types.js';\n\nconst LOG_LEVELS: Record<LogLevel, number> = {\n  debug: 0,\n  info: 1,\n  warn: 2,\n  error: 3\n};\n\n/**\n * Create a logger instance with the specified options\n */\nexport function createLogger(options: LoggerOptions): Logger {\n  const minLevel = LOG_LEVELS[options.level];\n  const includeTimestamp = options.timestamp ?? true;\n\n  function formatMessage(message: string): string {\n    if (includeTimestamp) {\n      const timestamp = new Date().toISOString();\n      return `[${timestamp}] ${message}`;\n    }\n    return message;\n  }\n\n  function shouldLog(level: LogLevel): boolean {\n    return LOG_LEVELS[level] >= minLevel;\n  }\n\n  return {\n    debug(message: string, ...args: unknown[]): void {\n      if (shouldLog('debug')) {\n        console.log(formatMessage(message), ...args);\n      }\n    },\n\n    info(message: string, ...args: unknown[]): void {\n      if (shouldLog('info')) {\n        console.info(formatMessage(message), ...args);\n      }\n    },\n\n    warn(message: string, ...args: unknown[]): void {\n      if (shouldLog('warn')) {\n        console.warn(formatMessage(message), ...args);\n      }\n    },\n\n    error(message: string, error?: Error, ...args: unknown[]): void {\n      if (shouldLog('error')) {\n        if (error) {\n          console.error(formatMessage(message), error, ...args);\n        } else {\n          console.error(formatMessage(message), ...args);\n        }\n      }\n    }\n  };\n}\n"
    },
    {
      "path": "src/index.ts",
      "operation": "create",
      "content": "/**\n * @test/logger - Simple typed logger utility\n */\n\nexport { createLogger } from './logger.js';\nexport type { Logger, LoggerOptions, LogLevel } from './types.js';\n"
    },
    {
      "path": "tests/logger.test.ts",
      "operation": "create",
      "content": "import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { createLogger } from '../src/logger.js';\nimport type { LogLevel } from '../src/types.js';\n\ndescribe('Logger', () => {\n  let consoleLogSpy: ReturnType<typeof vi.spyOn>;\n  let consoleInfoSpy: ReturnType<typeof vi.spyOn>;\n  let consoleWarnSpy: ReturnType<typeof vi.spyOn>;\n  let consoleErrorSpy: ReturnType<typeof vi.spyOn>;\n\n  beforeEach(() => {\n    consoleLogSpy = vi.spyOn(console, 'log').mockImplementation(() => {});\n    consoleInfoSpy = vi.spyOn(console, 'info').mockImplementation(() => {});\n    consoleWarnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});\n    consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});\n  });\n\n  afterEach(() => {\n    vi.restoreAllMocks();\n  });\n\n  it('should create a logger with default timestamp', () => {\n    const logger = createLogger({ level: 'info' });\n    expect(logger).toBeDefined();\n    expect(logger.debug).toBeTypeOf('function');\n    expect(logger.info).toBeTypeOf('function');\n    expect(logger.warn).toBeTypeOf('function');\n    expect(logger.error).toBeTypeOf('function');\n  });\n\n  it('should log info messages when level is info', () => {\n    const logger = createLogger({ level: 'info', timestamp: false });\n    logger.info('test message');\n    expect(consoleInfoSpy).toHaveBeenCalledWith('test message');\n  });\n\n  it('should not log debug messages when level is info', () => {\n    const logger = createLogger({ level: 'info', timestamp: false });\n    logger.debug('debug message');\n    expect(consoleLogSpy).not.toHaveBeenCalled();\n  });\n\n  it('should include timestamps when enabled', () => {\n    const logger = createLogger({ level: 'info', timestamp: true });\n    logger.info('test');\n    const call = consoleInfoSpy.mock.calls[0][0] as string;\n    expect(call).toMatch(/^\\[\\d{4}-\\d{2}-\\d{2}T.*\\] test$/);\n  });\n\n  it('should handle error objects', () => {\n    const logger = createLogger({ level: 'error', timestamp: false });\n    const error = new Error('test error');\n    logger.error('An error occurred', error);\n    expect(consoleErrorSpy).toHaveBeenCalledWith('An error occurred', error);\n  });\n\n  it('should filter by log level correctly', () => {\n    const levels: LogLevel[] = ['debug', 'info', 'warn', 'error'];\n    \n    levels.forEach((level) => {\n      const logger = createLogger({ level, timestamp: false });\n      \n      logger.debug('debug');\n      logger.info('info');\n      logger.warn('warn');\n      logger.error('error');\n\n      const debugCalled = consoleLogSpy.mock.calls.length > 0;\n      const infoCalled = consoleInfoSpy.mock.calls.length > 0;\n      const warnCalled = consoleWarnSpy.mock.calls.length > 0;\n      const errorCalled = consoleErrorSpy.mock.calls.length > 0;\n\n      if (level === 'debug') {\n        expect(debugCalled).toBe(true);\n        expect(infoCalled).toBe(true);\n        expect(warnCalled).toBe(true);\n        expect(errorCalled).toBe(true);\n      } else if (level === 'info') {\n        expect(debugCalled).toBe(false);\n        expect(infoCalled).toBe(true);\n        expect(warnCalled).toBe(true);\n        expect(errorCalled).toBe(true);\n      } else if (level === 'warn') {\n        expect(debugCalled).toBe(false);\n        expect(infoCalled).toBe(false);\n        expect(warnCalled).toBe(true);\n        expect(errorCalled).toBe(true);\n      } else if (level === 'error') {\n        expect(debugCalled).toBe(false);\n        expect(infoCalled).toBe(false);\n        expect(warnCalled).toBe(false);\n        expect(errorCalled).toBe(true);\n      }\n\n      vi.clearAllMocks();\n    });\n  });\n});\n"
    },
    {
      "path": "README.md",
      "operation": "create",
      "content": "# @test/logger\n\nSimple, typed logger utility for Node.js applications.\n\n## Installation\n\n```bash\nnpm install @test/logger\n```\n\n## Usage\n\n```typescript\nimport { createLogger } from '@test/logger';\n\n// Create a logger with info level\nconst logger = createLogger({ \n  level: 'info',\n  timestamp: true \n});\n\n// Log messages\nlogger.debug('This will not be shown');\nlogger.info('Application started');\nlogger.warn('This is a warning');\nlogger.error('An error occurred', new Error('Something went wrong'));\n```\n\n## API\n\n### `createLogger(options: LoggerOptions): Logger`\n\nCreate a new logger instance.\n\n**Options:**\n- `level` (required): Minimum log level to output (`'debug'` | `'info'` | `'warn'` | `'error'`)\n- `timestamp` (optional): Include timestamps in output (default: `true`)\n\n**Returns:** Logger instance with methods:\n- `debug(message: string, ...args: unknown[]): void`\n- `info(message: string, ...args: unknown[]): void`\n- `warn(message: string, ...args: unknown[]): void`\n- `error(message: string, error?: Error, ...args: unknown[]): void`\n\n## Log Levels\n\nLog levels in order of severity:\n1. `debug` - Detailed debug information\n2. `info` - Informational messages\n3. `warn` - Warning messages\n4. `error` - Error messages\n\nWhen you set a log level, only messages at that level or higher will be output.\n\n## License\n\nMIT\n"
    }
  ],
  "summary": "Created logger package with TypeScript strict mode, console-based transport, level filtering, timestamp support, and comprehensive Vitest tests with 100% coverage.",
  "qualityChecklist": {
    "strictModeEnabled": true,
    "noAnyTypes": true,
    "testCoverageAbove80": true,
    "allPublicFunctionsDocumented": true,
    "errorHandlingComplete": true
  },
  "questions": [
    {
      "question": "Should the logger support custom transports (e.g., file, network)?",
      "context": "The plan mentions extensibility but doesn't specify transport customization. Other utility packages in the monorepo might benefit from file logging.",
      "suggestedAnswer": "Add file transport in a follow-up task"
    }
  ],
  "suggestions": [
    {
      "type": "ADDITIONAL_FILE",
      "description": "Add vitest.config.ts for test configuration with coverage thresholds",
      "priority": "medium",
      "autoExecute": false
    },
    {
      "type": "FOLLOW_UP_TASK",
      "description": "Create file transport implementation with log rotation",
      "priority": "low",
      "autoExecute": false
    }
  ]
}
