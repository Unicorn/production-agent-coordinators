/**
 * Connection Path Utilities
 * Calculate signal/query paths, detect circular dependencies
 */

import type {
  WorkflowConnection,
  ConnectionPath,
  EnhancedWorkflowNode,
  WorkflowSignal,
  WorkflowQuery,
  WorkflowWorkQueue,
} from '@/types/advanced-patterns';

/**
 * Build a workflow connection from a child workflow node that signals to parent
 */
export function buildSignalConnection(
  childNode: EnhancedWorkflowNode,
  parentWorkflowId: string,
  signal?: WorkflowSignal,
  workQueue?: WorkflowWorkQueue
): WorkflowConnection | null {
  if (!childNode.signal_to_parent) return null;

  return {
    id: `${childNode.id}-signal-parent`,
    type: 'signal',
    fromNodeId: childNode.node_id,
    toNodeId: workQueue?.id || parentWorkflowId,
    fromType: childNode.type === 'scheduled-workflow' ? 'scheduled' : 'child',
    toType: workQueue ? 'work-queue' : 'parent',
    label: childNode.signal_to_parent,
    metadata: {
      signalName: childNode.signal_to_parent,
      queueName: childNode.work_queue_target || undefined,
      autoGenerated: signal?.auto_generated || false,
    },
  };
}

/**
 * Build a workflow connection from a child workflow node that queries parent
 */
export function buildQueryConnection(
  childNode: EnhancedWorkflowNode,
  parentWorkflowId: string,
  query?: WorkflowQuery
): WorkflowConnection | null {
  if (!childNode.query_parent) return null;

  return {
    id: `${childNode.id}-query-parent`,
    type: 'query',
    fromNodeId: childNode.node_id,
    toNodeId: parentWorkflowId,
    fromType: childNode.type === 'scheduled-workflow' ? 'scheduled' : 'child',
    toType: 'parent',
    label: childNode.query_parent,
    metadata: {
      queryName: childNode.query_parent,
      autoGenerated: query?.auto_generated || false,
    },
  };
}

/**
 * Build blocking dependency connections
 */
export function buildBlockingConnections(
  childNode: EnhancedWorkflowNode,
  allNodes: EnhancedWorkflowNode[]
): WorkflowConnection[] {
  const connections: WorkflowConnection[] = [];

  // Blocking on queue
  if (childNode.block_until_queue) {
    connections.push({
      id: `${childNode.id}-block-queue`,
      type: 'blocking',
      fromNodeId: childNode.block_until_queue,
      toNodeId: childNode.node_id,
      fromType: 'activity',
      toType: 'work-queue',
      label: 'Blocks until queue ready',
      metadata: {
        queueName: childNode.block_until_queue,
      },
    });
  }

  // Blocking on work items
  if (childNode.block_until_work_items && childNode.block_until_work_items.length > 0) {
    childNode.block_until_work_items.forEach((workItemId) => {
      const dependencyNode = allNodes.find((n) => n.node_id === workItemId);
      if (dependencyNode) {
        connections.push({
          id: `${childNode.id}-block-${workItemId}`,
          type: 'blocking',
          fromNodeId: workItemId,
          toNodeId: childNode.node_id,
          fromType: 'child',
          toType: 'child',
          label: 'Blocks until complete',
          metadata: {},
        });
      }
    });
  }

  return connections;
}

/**
 * Build all connections for a workflow
 */
export function buildAllConnections(
  nodes: EnhancedWorkflowNode[],
  workflowId: string,
  signals?: WorkflowSignal[],
  queries?: WorkflowQuery[],
  workQueues?: WorkflowWorkQueue[]
): WorkflowConnection[] {
  const connections: WorkflowConnection[] = [];

  nodes.forEach((node) => {
    // Signal connections
    if (node.signal_to_parent) {
      const signal = signals?.find((s) => s.signal_name === node.signal_to_parent);
      const workQueue = workQueues?.find((wq) => wq.signal_name === node.signal_to_parent);
      const connection = buildSignalConnection(node, workflowId, signal, workQueue);
      if (connection) connections.push(connection);
    }

    // Query connections
    if (node.query_parent) {
      const query = queries?.find((q) => q.query_name === node.query_parent);
      const connection = buildQueryConnection(node, workflowId, query);
      if (connection) connections.push(connection);
    }

    // Blocking connections
    const blockingConnections = buildBlockingConnections(node, nodes);
    connections.push(...blockingConnections);
  });

  return connections;
}

/**
 * Detect circular dependencies in blocking relationships
 */
export function detectCircularDependencies(
  nodes: EnhancedWorkflowNode[]
): { hasCircularDependency: boolean; cycle?: string[]; message?: string } {
  const graph = new Map<string, string[]>();

  // Build dependency graph
  nodes.forEach((node) => {
    const dependencies: string[] = [];
    
    if (node.block_until_work_items) {
      dependencies.push(...node.block_until_work_items);
    }
    
    graph.set(node.node_id, dependencies);
  });

  // DFS to detect cycles
  const visited = new Set<string>();
  const recursionStack = new Set<string>();
  const cyclePath: string[] = [];

  function hasCycle(nodeId: string, path: string[]): boolean {
    visited.add(nodeId);
    recursionStack.add(nodeId);
    path.push(nodeId);

    const dependencies = graph.get(nodeId) || [];
    for (const depId of dependencies) {
      if (!visited.has(depId)) {
        if (hasCycle(depId, path)) {
          return true;
        }
      } else if (recursionStack.has(depId)) {
        // Found cycle
        const cycleStartIndex = path.indexOf(depId);
        cyclePath.push(...path.slice(cycleStartIndex));
        return true;
      }
    }

    recursionStack.delete(nodeId);
    path.pop();
    return false;
  }

  for (const nodeId of graph.keys()) {
    if (!visited.has(nodeId)) {
      if (hasCycle(nodeId, [])) {
        return {
          hasCircularDependency: true,
          cycle: cyclePath,
          message: `Circular dependency detected: ${cyclePath.join(' → ')} → ${cyclePath[0]}`,
        };
      }
    }
  }

  return { hasCircularDependency: false };
}

/**
 * Calculate all connection paths in a workflow
 */
export function calculateConnectionPaths(
  connections: WorkflowConnection[]
): ConnectionPath[] {
  const paths: ConnectionPath[] = [];
  const visited = new Set<string>();

  // Build adjacency list
  const adjacencyList = new Map<string, WorkflowConnection[]>();
  connections.forEach((conn) => {
    if (!adjacencyList.has(conn.fromNodeId)) {
      adjacencyList.set(conn.fromNodeId, []);
    }
    adjacencyList.get(conn.fromNodeId)!.push(conn);
  });

  // DFS to find all paths
  function findPaths(
    currentNodeId: string,
    currentPath: WorkflowConnection[],
    visitedInPath: Set<string>
  ) {
    if (visitedInPath.has(currentNodeId)) {
      // Cyclic path detected
      paths.push({
        connections: [...currentPath],
        path: currentPath.map((c) => c.fromNodeId).concat(currentNodeId),
        cyclic: true,
      });
      return;
    }

    visitedInPath.add(currentNodeId);

    const outgoingConnections = adjacencyList.get(currentNodeId) || [];
    if (outgoingConnections.length === 0) {
      // End of path
      if (currentPath.length > 0) {
        paths.push({
          connections: [...currentPath],
          path: currentPath.map((c) => c.fromNodeId).concat(currentNodeId),
          cyclic: false,
        });
      }
    } else {
      outgoingConnections.forEach((conn) => {
        findPaths(conn.toNodeId, [...currentPath, conn], new Set(visitedInPath));
      });
    }

    visitedInPath.delete(currentNodeId);
  }

  // Start from all nodes with no incoming connections
  const nodesWithIncoming = new Set(connections.map((c) => c.toNodeId));
  const startNodes = new Set(
    connections.map((c) => c.fromNodeId).filter((id) => !nodesWithIncoming.has(id))
  );

  startNodes.forEach((startNode) => {
    findPaths(startNode, [], new Set());
  });

  return paths;
}

/**
 * Validate connection integrity
 */
export function validateConnectionIntegrity(
  connections: WorkflowConnection[],
  nodes: EnhancedWorkflowNode[],
  signals?: WorkflowSignal[],
  queries?: WorkflowQuery[],
  workQueues?: WorkflowWorkQueue[]
): { valid: boolean; errors: string[] } {
  const errors: string[] = [];
  const nodeIds = new Set(nodes.map((n) => n.node_id));
  const signalNames = new Set(signals?.map((s) => s.signal_name) || []);
  const queryNames = new Set(queries?.map((q) => q.query_name) || []);
  const queueNames = new Set(workQueues?.map((wq) => wq.queue_name) || []);

  connections.forEach((conn) => {
    // Validate nodes exist
    if (conn.fromType === 'child' && !nodeIds.has(conn.fromNodeId)) {
      errors.push(`Connection ${conn.id}: From node ${conn.fromNodeId} does not exist`);
    }
    if (conn.toType === 'child' && !nodeIds.has(conn.toNodeId)) {
      errors.push(`Connection ${conn.id}: To node ${conn.toNodeId} does not exist`);
    }

    // Validate signal/query/queue names
    if (conn.type === 'signal' && conn.metadata.signalName) {
      if (!signalNames.has(conn.metadata.signalName)) {
        errors.push(`Connection ${conn.id}: Signal ${conn.metadata.signalName} does not exist`);
      }
    }
    if (conn.type === 'query' && conn.metadata.queryName) {
      if (!queryNames.has(conn.metadata.queryName)) {
        errors.push(`Connection ${conn.id}: Query ${conn.metadata.queryName} does not exist`);
      }
    }
    if (conn.metadata.queueName) {
      if (!queueNames.has(conn.metadata.queueName)) {
        errors.push(`Connection ${conn.id}: Work queue ${conn.metadata.queueName} does not exist`);
      }
    }
  });

  return {
    valid: errors.length === 0,
    errors,
  };
}

/**
 * Get connection summary statistics
 */
export function getConnectionStats(connections: WorkflowConnection[]) {
  return {
    total: connections.length,
    byType: {
      signal: connections.filter((c) => c.type === 'signal').length,
      query: connections.filter((c) => c.type === 'query').length,
      blocking: connections.filter((c) => c.type === 'blocking').length,
    },
    autoGenerated: connections.filter((c) => c.metadata.autoGenerated).length,
    workQueueConnections: connections.filter((c) => c.toType === 'work-queue').length,
  };
}

