'use client';

import { Card, YStack, XStack, Text, Button, ScrollView, Separator } from 'tamagui';
import { Badge } from '../shared/Badge';
import { Network, X, AlertCircle, CheckCircle, ArrowRight } from 'lucide-react';
import { useState, useEffect } from 'react';
import type {
  WorkflowConnection,
  ConnectionPath,
  EnhancedWorkflowNode,
  WorkflowSignal,
  WorkflowQuery,
  WorkflowWorkQueue,
} from '@/types/advanced-patterns';
import {
  buildAllConnections,
  detectCircularDependencies,
  calculateConnectionPaths,
  validateConnectionIntegrity,
  getConnectionStats,
} from '@/utils/connection-path-utils';

interface WorkQueueConnectionVisualizerProps {
  nodes: EnhancedWorkflowNode[];
  workflowId: string;
  signals?: WorkflowSignal[];
  queries?: WorkflowQuery[];
  workQueues?: WorkflowWorkQueue[];
  onClose?: () => void;
}

export function WorkQueueConnectionVisualizer({
  nodes,
  workflowId,
  signals,
  queries,
  workQueues,
  onClose,
}: WorkQueueConnectionVisualizerProps) {
  const [selectedConnection, setSelectedConnection] = useState<WorkflowConnection | null>(null);
  const [connections, setConnections] = useState<WorkflowConnection[]>([]);
  const [paths, setPaths] = useState<ConnectionPath[]>([]);
  const [circularCheck, setCircularCheck] = useState<{
    hasCircularDependency: boolean;
    cycle?: string[];
    message?: string;
  }>({ hasCircularDependency: false });

  useEffect(() => {
    // Build all connections
    const allConnections = buildAllConnections(
      nodes,
      workflowId,
      signals,
      queries,
      workQueues
    );
    setConnections(allConnections);

    // Calculate paths
    const connectionPaths = calculateConnectionPaths(allConnections);
    setPaths(connectionPaths);

    // Check for circular dependencies
    const circularDeps = detectCircularDependencies(nodes);
    setCircularCheck(circularDeps);
  }, [nodes, workflowId, signals, queries, workQueues]);

  const stats = getConnectionStats(connections);
  const validation = validateConnectionIntegrity(connections, nodes, signals, queries, workQueues);

  const getConnectionTypeColor = (type: string) => {
    switch (type) {
      case 'signal':
        return '$orange9';
      case 'query':
        return '$teal9';
      case 'blocking':
        return '$red9';
      default:
        return '$gray9';
    }
  };

  const getConnectionTypeBadgeColor = (type: string) => {
    switch (type) {
      case 'signal':
        return '$orange5';
      case 'query':
        return '$teal5';
      case 'blocking':
        return '$red5';
      default:
        return '$gray5';
    }
  };

  return (
    <Card
      p="$4"
      borderWidth={1}
      borderColor="$borderColor"
      maxWidth="800px"
      maxHeight="80vh"
      position="relative"
    >
      <YStack gap="$4" height="100%">
        {/* Header */}
        <XStack ai="center" jc="space-between">
          <XStack ai="center" gap="$3">
            <Network size={24} color="$blue9" />
            <YStack gap="$1">
              <Text fontSize="$6" fontWeight="600">
                Connection Visualizer
              </Text>
              <Text fontSize="$3" color="$gray11">
                All signal/query connection paths in this workflow
              </Text>
            </YStack>
          </XStack>

          {onClose && (
            <Button size="$2" icon={X} onPress={onClose} chromeless>
              Close
            </Button>
          )}
        </XStack>

        {/* Stats Summary */}
        <XStack gap="$3" flexWrap="wrap">
          <Badge bg="$blue5">
            Total: {stats.total} connections
          </Badge>
          <Badge bg="$orange5">
            üì§ {stats.byType.signal} Signals
          </Badge>
          <Badge bg="$teal5">
            üîç {stats.byType.query} Queries
          </Badge>
          <Badge bg="$red5">
            üö´ {stats.byType.blocking} Blocking
          </Badge>
          {stats.autoGenerated > 0 && (
            <Badge bg="$purple5">
              ‚ö° {stats.autoGenerated} Auto-generated
            </Badge>
          )}
        </XStack>

        {/* Validation Status */}
        {!validation.valid && (
          <Card bg="$red2" p="$3" borderWidth={1} borderColor="$red6">
            <XStack ai="center" gap="$2">
              <AlertCircle size={16} color="$red11" />
              <YStack gap="$1" flex={1}>
                <Text fontSize="$3" fontWeight="600" color="$red11">
                  Connection Validation Errors
                </Text>
                {validation.errors.map((error, idx) => (
                  <Text key={idx} fontSize="$2" color="$red11">
                    ‚Ä¢ {error}
                  </Text>
                ))}
              </YStack>
            </XStack>
          </Card>
        )}

        {/* Circular Dependency Warning */}
        {circularCheck.hasCircularDependency && (
          <Card bg="$orange2" p="$3" borderWidth={1} borderColor="$orange6">
            <XStack ai="center" gap="$2">
              <AlertCircle size={16} color="$orange11" />
              <YStack gap="$1" flex={1}>
                <Text fontSize="$3" fontWeight="600" color="$orange11">
                  Circular Dependency Detected
                </Text>
                <Text fontSize="$2" color="$orange11">
                  {circularCheck.message}
                </Text>
              </YStack>
            </XStack>
          </Card>
        )}

        {/* Success Message */}
        {validation.valid && !circularCheck.hasCircularDependency && connections.length > 0 && (
          <Card bg="$green2" p="$3" borderWidth={1} borderColor="$green6">
            <XStack ai="center" gap="$2">
              <CheckCircle size={16} color="$green11" />
              <Text fontSize="$3" fontWeight="600" color="$green11">
                All connections valid, no circular dependencies
              </Text>
            </XStack>
          </Card>
        )}

        <Separator />

        {/* Connections List */}
        <ScrollView flex={1} showsVerticalScrollIndicator>
          <YStack gap="$3">
            <Text fontSize="$5" fontWeight="600">
              All Connections ({connections.length})
            </Text>

            {connections.length === 0 && (
              <Card bg="$gray2" p="$4" borderWidth={1} borderColor="$gray6">
                <Text fontSize="$3" color="$gray11" textAlign="center">
                  No connections found. Add child workflows with parent communication
                  to see connections here.
                </Text>
              </Card>
            )}

            {connections.map((connection) => (
              <Card
                key={connection.id}
                p="$3"
                borderWidth={2}
                borderColor={
                  selectedConnection?.id === connection.id
                    ? getConnectionTypeColor(connection.type)
                    : '$gray6'
                }
                onPress={() => setSelectedConnection(connection)}
                pressStyle={{ backgroundColor: '$gray2' }}
                cursor="pointer"
              >
                <YStack gap="$2">
                  <XStack ai="center" jc="space-between">
                    <XStack ai="center" gap="$2">
                      <Badge bg={getConnectionTypeBadgeColor(connection.type)}>
                        {connection.type.toUpperCase()}
                      </Badge>
                      {connection.metadata.autoGenerated && (
                        <Badge size="$1" bg="$purple5">
                          AUTO
                        </Badge>
                      )}
                    </XStack>
                    <Text fontSize="$2" color="$gray11" fontFamily="$mono">
                      {connection.id}
                    </Text>
                  </XStack>

                  {/* Connection Path */}
                  <XStack ai="center" gap="$2" flexWrap="wrap">
                    <Text fontSize="$3" fontWeight="500">
                      {connection.fromNodeId}
                    </Text>
                    <ArrowRight size={16} color="$gray11" />
                    <Text fontSize="$3" fontWeight="500">
                      {connection.toNodeId}
                    </Text>
                  </XStack>

                  {/* Connection Label */}
                  <Text fontSize="$2" color="$gray11">
                    {connection.label}
                  </Text>

                  {/* Metadata */}
                  {connection.metadata && Object.keys(connection.metadata).length > 0 && (
                    <XStack gap="$2" flexWrap="wrap">
                      {connection.metadata.signalName && (
                        <Text fontSize="$2" color="$orange11" fontFamily="$mono">
                          üì§ {connection.metadata.signalName}
                        </Text>
                      )}
                      {connection.metadata.queryName && (
                        <Text fontSize="$2" color="$teal11" fontFamily="$mono">
                          üîç {connection.metadata.queryName}
                        </Text>
                      )}
                      {connection.metadata.queueName && (
                        <Text fontSize="$2" color="$yellow11" fontFamily="$mono">
                          üì• Queue: {connection.metadata.queueName}
                        </Text>
                      )}
                    </XStack>
                  )}
                </YStack>
              </Card>
            ))}
          </YStack>
        </ScrollView>

        {/* Connection Paths Section */}
        {paths.length > 0 && (
          <>
            <Separator />
            <YStack gap="$3">
              <Text fontSize="$5" fontWeight="600">
                Connection Paths ({paths.length})
              </Text>

              <ScrollView maxHeight="200px" showsVerticalScrollIndicator>
                <YStack gap="$2">
                  {paths.map((path, idx) => (
                    <Card
                      key={idx}
                      p="$2"
                      bg={path.cyclic ? '$red2' : '$gray2'}
                      borderWidth={1}
                      borderColor={path.cyclic ? '$red6' : '$gray6'}
                    >
                      <XStack ai="center" gap="$2">
                        {path.cyclic && <AlertCircle size={14} color="$red11" />}
                        <Text fontSize="$2" color={path.cyclic ? '$red11' : '$gray11'} flex={1}>
                          {path.path.join(' ‚Üí ')}
                        </Text>
                        {path.cyclic && (
                          <Badge size="$1" bg="$red5">
                            CYCLIC
                          </Badge>
                        )}
                      </XStack>
                    </Card>
                  ))}
                </YStack>
              </ScrollView>
            </YStack>
          </>
        )}
      </YStack>
    </Card>
  );
}

