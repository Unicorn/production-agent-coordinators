/**
 * TypeScript Code Generator
 * Generates TypeScript code from compiled workflow blocks
 */

import type { WorkflowDefinition, CodeBlock, GeneratorContext } from '../types';
import { indent, toCamelCase, generateJSDoc, mergeImports } from '../utils/ast-helpers';

/**
 * Build imports from code blocks
 * Exported for unit testing of import collection and merging.
 */
export function buildImports(codeBlocks: CodeBlock[]): string[] {
  const allImports: string[] = [];
  for (const block of codeBlocks) {
    if (block.imports) {
      allImports.push(...block.imports);
    }
  }
  return mergeImports(allImports);
}

/**
 * Build declarations from code blocks
 * Exported for unit testing of declaration collection.
 */
export function buildDeclarations(codeBlocks: CodeBlock[]): string[] {
  const declarations: string[] = [];
  for (const block of codeBlocks) {
    if (block.declarations) {
      declarations.push(...block.declarations);
    }
  }
  return declarations;
}

/**
 * Generate complete workflow TypeScript file
 */
export function generateWorkflowFile(
  workflow: WorkflowDefinition,
  codeBlocks: CodeBlock[],
  context: GeneratorContext,
  includeComments = true
): string {
  // Use workflow name directly - Temporal expects function name to match workflow type name
  // The workflow.name is the type name used when starting workflows
  const workflowName = workflow.name;

  // Build imports and declarations
  const imports = buildImports(codeBlocks);
  const declarations = buildDeclarations(codeBlocks);

  // Combine code blocks
  const workflowBody = codeBlocks
    .map(block => block.code)
    .filter(code => code.trim().length > 0)
    .join('\n\n');

  // Find the last result variable from code blocks to return
  const lastResultVar = codeBlocks
    .map(block => block.resultVar)
    .filter((v): v is string => !!v)
    .pop() || null;

  // Generate workflow function
  const workflowFunction = generateWorkflowFunction(
    workflowName,
    workflow.settings.description,
    declarations,
    workflowBody,
    includeComments,
    lastResultVar
  );

  // Combine all parts
  const parts: string[] = [];

  if (imports.length > 0) {
    parts.push(imports.join('\n'));
  }

  if (includeComments) {
    parts.push(generateJSDoc(`
Workflow: ${workflow.name}
${workflow.settings.description || 'Auto-generated Temporal workflow'}
Generated by Pattern-Based Compiler v1.0
`.trim()));
  }

  parts.push(workflowFunction);

  return parts.join('\n\n') + '\n';
}

/**
 * Generate workflow function
 * Exported for unit testing of generated function structure.
 */
export function generateWorkflowFunction(
  name: string,
  description: string | undefined,
  declarations: string[],
  body: string,
  includeComments: boolean,
  lastResultVar: string | null = null
): string {
  const parts: string[] = [];

  if (includeComments && description) {
    parts.push(generateJSDoc(description));
  }

  // Temporal expects the function name to match the workflow type name exactly
  // The name parameter is the workflow.name from the definition
  parts.push(`export async function ${name}(input: any): Promise<any> {`);

  if (declarations.length > 0) {
    parts.push(declarations.map(d => indent(1) + d).join('\n'));
    parts.push('');
  }

  // Add body with proper indentation
  const indentedBody = body
    .split('\n')
    .map(line => line.length > 0 ? indent(1) + line : line)
    .join('\n');

  parts.push(indentedBody);

  // Return the last result variable if available, otherwise return success
  parts.push('');
  if (lastResultVar) {
    parts.push(indent(1) + `return ${lastResultVar};`);
  } else {
    parts.push(indent(1) + 'return { success: true };');
  }
  parts.push('}');

  return parts.join('\n');
}

/**
 * Generate activities file
 */
export function generateActivitiesFile(
  workflow: WorkflowDefinition,
  includeComments = true
): string {
  const parts: string[] = [];

  if (includeComments) {
    parts.push(generateJSDoc(`
Activities for ${workflow.name}
Auto-generated activity stubs - implement business logic here
`.trim()));
  }

  // Find all activity and agent nodes
  const activityNodes = workflow.nodes.filter(
    n => n.type === 'activity' || n.type === 'agent'
  );

  if (activityNodes.length === 0) {
    parts.push(`
export async function placeholderActivity(input: any): Promise<any> {
  return { success: true };
}
`.trim());
  } else {
    for (const node of activityNodes) {
      const activityName = node.data.componentName || toCamelCase(node.id);
      const description = node.data.label || node.id;

      if (includeComments) {
        parts.push(generateJSDoc(description));
      }

      parts.push(`export async function ${activityName}(input: any): Promise<any> {`);

      if (includeComments) {
        parts.push(indent(1) + '// TODO: Implement activity logic');
      }

      parts.push(indent(1) + `console.log('Executing ${activityName}', input);`);

      if (node.type === 'agent' && includeComments) {
        parts.push(indent(1) + '// This is an AI agent activity');
        parts.push(indent(1) + '// Call your LLM provider here');
      }

      parts.push(indent(1) + 'return { success: true, data: input };');
      parts.push('}');
      parts.push('');
    }
  }

  return parts.join('\n') + '\n';
}

/**
 * Generate worker file
 */
export function generateWorkerFile(
  workflow: WorkflowDefinition,
  includeComments = true
): string {
  const taskQueue = workflow.settings.taskQueue || 'default';

  const parts: string[] = [];

  if (includeComments) {
    parts.push(generateJSDoc(`
Temporal Worker for ${workflow.name}
Auto-generated from workflow definition
`.trim()));
  }

  parts.push(`import { Worker, NativeConnection } from '@temporalio/worker';`);
  parts.push(`import * as activities from './activities';`);
  parts.push('');
  parts.push('async function run() {');

  if (includeComments) {
    parts.push(indent(1) + '// Create connection to Temporal server');
  }
  parts.push(indent(1) + 'const connection = await NativeConnection.connect({');
  parts.push(indent(2) + "address: process.env.TEMPORAL_ADDRESS || 'localhost:7233',");
  parts.push(indent(1) + '});');
  parts.push('');

  if (includeComments) {
    parts.push(indent(1) + '// Create worker with connection');
  }
  parts.push(indent(1) + 'const worker = await Worker.create({');
  parts.push(indent(2) + 'connection,');
  parts.push(indent(2) + "namespace: process.env.TEMPORAL_NAMESPACE || 'default',");
  parts.push(indent(2) + "workflowsPath: require.resolve('./workflows'),");
  parts.push(indent(2) + 'activities,');
  parts.push(indent(2) + `taskQueue: process.env.TEMPORAL_TASK_QUEUE || '${taskQueue}',`);
  parts.push(indent(1) + '});');
  parts.push('');

  if (includeComments) {
    parts.push(indent(1) + '// Start worker');
  }
  parts.push(indent(1) + 'await worker.run();');
  parts.push('}');
  parts.push('');
  parts.push('run().catch((err) => {');
  parts.push(indent(1) + "console.error('Worker error:', err);");
  parts.push(indent(1) + 'process.exit(1);');
  parts.push('});');

  return parts.join('\n') + '\n';
}

/**
 * Generate package.json
 */
export function generatePackageJson(
  workflow: WorkflowDefinition
): string {
  const packageName = workflow.name.toLowerCase().replace(/[^a-z0-9-]/g, '-');

  const pkg = {
    name: packageName,
    version: workflow.settings.version || '1.0.0',
    description: workflow.settings.description || `Temporal workflow: ${workflow.name}`,
    main: 'dist/worker.js',
    scripts: {
      build: 'tsc',
      'start.watch': 'nodemon dist/worker.js',
      start: 'node dist/worker.js',
    },
    dependencies: {
      '@temporalio/worker': '^1.10.0',
      '@temporalio/workflow': '^1.10.0',
      '@temporalio/activity': '^1.10.0',
      '@temporalio/client': '^1.10.0',
    },
    devDependencies: {
      '@types/node': '^20.0.0',
      nodemon: '^3.0.0',
      typescript: '^5.0.0',
    },
  };

  return JSON.stringify(pkg, null, 2) + '\n';
}

/**
 * Generate tsconfig.json
 */
export function generateTsConfig(strictMode = true): string {
  const config = {
    compilerOptions: {
      target: 'es2020',
      module: 'commonjs',
      lib: ['es2020'],
      outDir: './dist',
      rootDir: './src',
      strict: strictMode,
      esModuleInterop: true,
      skipLibCheck: true,
      forceConsistentCasingInFileNames: true,
      resolveJsonModule: true,
      declaration: true,
    },
    include: ['src/**/*'],
    exclude: ['node_modules', 'dist'],
  };

  return JSON.stringify(config, null, 2) + '\n';
}
