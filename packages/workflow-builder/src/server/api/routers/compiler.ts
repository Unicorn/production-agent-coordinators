import { z } from 'zod';
import { createTRPCRouter, protectedProcedure } from '../trpc';
import { TRPCError } from '@trpc/server';
import { compileWorkflow } from '@/lib/workflow-compiler/compiler';
import type { TemporalWorkflow } from '@/types/advanced-patterns';

export const compilerRouter = createTRPCRouter({
  /**
   * Compile a workflow into executable TypeScript code
   */
  compile: protectedProcedure
    .input(z.object({
      workflowId: z.string(),
      includeComments: z.boolean().default(true),
      strictMode: z.boolean().default(true),
    }))
    .mutation(async ({ ctx, input }) => {
      // Fetch workflow with all related data
      const { data: workflowData, error: workflowError } = await ctx.supabase
        .from('workflows')
        .select(`
          *,
          workflow_nodes(*),
          workflow_edges(*)
        `)
        .eq('id', input.workflowId)
        .eq('created_by', ctx.user.id)
        .single();

      if (workflowError || !workflowData) {
        throw new TRPCError({
          code: 'NOT_FOUND',
          message: 'Workflow not found or not authorized',
        });
      }

      // Fetch work queues
      const { data: workQueues } = await ctx.supabase
        .from('workflow_work_queues')
        .select('*')
        .eq('workflow_id', input.workflowId);

      // Fetch signals
      const { data: signals } = await ctx.supabase
        .from('workflow_signals')
        .select('*')
        .eq('workflow_id', input.workflowId);

      // Fetch queries
      const { data: queries } = await ctx.supabase
        .from('workflow_queries')
        .select('*')
        .eq('workflow_id', input.workflowId);

      // Convert to TemporalWorkflow format
      const workflow: TemporalWorkflow = {
        id: workflowData.id,
        name: workflowData.name,
        description: workflowData.description,
        stages: workflowData.workflow_nodes?.map((node: any) => ({
          id: node.node_id,
          type: node.node_type_id,
          position: { x: node.position_x, y: node.position_y },
          metadata: node.metadata,
        })) || [],
        transitions: workflowData.workflow_edges?.map((edge: any) => ({
          from: edge.source_node_id,
          to: edge.target_node_id,
          condition: edge.label,
        })) || [],
        workQueues: workQueues?.map(wq => ({
          id: wq.id,
          workflowId: wq.workflow_id,
          name: wq.queue_name,
          description: wq.description,
          signalName: wq.signal_name,
          queryName: wq.query_name,
          maxSize: wq.max_size,
          priority: wq.priority as 'fifo' | 'lifo' | 'priority',
          deduplicate: wq.deduplicate,
          workItemSchema: wq.work_item_schema,
          createdAt: new Date(wq.created_at),
          updatedAt: new Date(wq.updated_at),
        })) || [],
        signals: signals?.map(s => ({
          id: s.id,
          workflowId: s.workflow_id,
          name: s.signal_name,
          description: s.description,
          parametersSchema: s.parameters_schema,
          autoGenerated: s.auto_generated,
          createdAt: new Date(s.created_at),
        })) || [],
        queries: queries?.map(q => ({
          id: q.id,
          workflowId: q.workflow_id,
          name: q.query_name,
          description: q.description,
          returnTypeSchema: q.return_type_schema,
          autoGenerated: q.auto_generated,
          createdAt: new Date(q.created_at),
        })) || [],
      };

      // Compile the workflow
      const compiled = compileWorkflow(workflow, {
        includeComments: input.includeComments,
        strictMode: input.strictMode,
      });

      return {
        success: true,
        compiled,
        workflow: {
          id: workflowData.id,
          name: workflowData.name,
        },
      };
    }),

  /**
   * Preview generated code without saving
   */
  preview: protectedProcedure
    .input(z.object({
      workflowId: z.string(),
    }))
    .query(async ({ ctx, input }) => {
      // Same logic as compile, but return preview only
      const result = await ctx.procedure.compile({
        workflowId: input.workflowId,
        includeComments: true,
        strictMode: true,
      });

      return {
        workflowCode: result.compiled.workflowCode,
        activitiesCode: result.compiled.activitiesCode,
        workerCode: result.compiled.workerCode,
      };
    }),
});

