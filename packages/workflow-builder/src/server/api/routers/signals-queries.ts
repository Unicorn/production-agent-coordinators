import { z } from 'zod';
import { createTRPCRouter, protectedProcedure } from '../trpc';
import { TRPCError } from '@trpc/server';
import { validateSignalQueryUniqueness } from '@/utils/dependency-validation';

/**
 * Signals Router
 * 
 * Manages signal handlers on workflows
 */
export const signalsRouter = createTRPCRouter({
  // List signals for a workflow
  list: protectedProcedure
    .input(
      z.object({
        workflowId: z.string().uuid(),
        includeAutoGenerated: z.boolean().default(true),
      })
    )
    .query(async ({ ctx, input }) => {
      let query = ctx.supabase
        .from('workflow_signals')
        .select('*')
        .eq('workflow_id', input.workflowId);

      if (!input.includeAutoGenerated) {
        query = query.eq('auto_generated', false);
      }

      const { data, error } = await query.order('signal_name', { ascending: true });

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        });
      }

      return {
        signals: data || [],
      };
    }),

  // Get single signal
  get: protectedProcedure
    .input(
      z.object({
        id: z.string().uuid(),
      })
    )
    .query(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabase
        .from('workflow_signals')
        .select('*')
        .eq('id', input.id)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Signal not found',
          });
        }
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        });
      }

      return {
        signal: data,
      };
    }),

  // Create signal
  create: protectedProcedure
    .input(
      z.object({
        workflowId: z.string().uuid(),
        signalName: z.string().min(1).max(100),
        description: z.string().optional(),
        parameters: z.record(z.any()).optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      // Check if signal name already exists for this workflow
      const { data: existing } = await ctx.supabase
        .from('workflow_signals')
        .select('id')
        .eq('workflow_id', input.workflowId)
        .eq('signal_name', input.signalName)
        .single();

      if (existing) {
        throw new TRPCError({
          code: 'CONFLICT',
          message: `Signal '${input.signalName}' already exists for this workflow`,
        });
      }

      // Create signal
      const { data, error } = await ctx.supabase
        .from('workflow_signals')
        .insert({
          workflow_id: input.workflowId,
          signal_name: input.signalName,
          description: input.description,
          parameters: input.parameters || null,
          auto_generated: false,
          created_by: ctx.user.id,
        })
        .select()
        .single();

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        });
      }

      return {
        signal: data,
      };
    }),

  // Update signal
  update: protectedProcedure
    .input(
      z.object({
        id: z.string().uuid(),
        signalName: z.string().min(1).max(100).optional(),
        description: z.string().optional(),
        parameters: z.record(z.any()).optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const { id, ...updates } = input;

      // Check if this is auto-generated (can't be modified)
      const { data: signal } = await ctx.supabase
        .from('workflow_signals')
        .select('auto_generated, workflow_id')
        .eq('id', id)
        .single();

      if (signal?.auto_generated) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'Cannot modify auto-generated signal handlers',
        });
      }

      // If updating signal name, validate uniqueness
      if (updates.signalName && signal) {
        const { data: existing } = await ctx.supabase
          .from('workflow_signals')
          .select('id')
          .eq('workflow_id', signal.workflow_id)
          .eq('signal_name', updates.signalName)
          .neq('id', id)
          .single();

        if (existing) {
          throw new TRPCError({
            code: 'CONFLICT',
            message: `Signal '${updates.signalName}' already exists for this workflow`,
          });
        }
      }

      const { data, error } = await ctx.supabase
        .from('workflow_signals')
        .update({
          signal_name: updates.signalName,
          description: updates.description,
          parameters: updates.parameters,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .select()
        .single();

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        });
      }

      return {
        signal: data,
      };
    }),

  // Delete signal
  delete: protectedProcedure
    .input(
      z.object({
        id: z.string().uuid(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      // Check if this is auto-generated (can't be deleted directly)
      const { data: signal } = await ctx.supabase
        .from('workflow_signals')
        .select('auto_generated')
        .eq('id', input.id)
        .single();

      if (signal?.auto_generated) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'Cannot delete auto-generated signal handlers. Delete the associated work queue instead.',
        });
      }

      const { error } = await ctx.supabase
        .from('workflow_signals')
        .delete()
        .eq('id', input.id);

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        });
      }

      return {
        success: true,
      };
    }),
});

/**
 * Queries Router
 * 
 * Manages query handlers on workflows
 */
export const queriesRouter = createTRPCRouter({
  // List queries for a workflow
  list: protectedProcedure
    .input(
      z.object({
        workflowId: z.string().uuid(),
        includeAutoGenerated: z.boolean().default(true),
      })
    )
    .query(async ({ ctx, input }) => {
      let query = ctx.supabase
        .from('workflow_queries')
        .select('*')
        .eq('workflow_id', input.workflowId);

      if (!input.includeAutoGenerated) {
        query = query.eq('auto_generated', false);
      }

      const { data, error } = await query.order('query_name', { ascending: true });

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        });
      }

      return {
        queries: data || [],
      };
    }),

  // Get single query
  get: protectedProcedure
    .input(
      z.object({
        id: z.string().uuid(),
      })
    )
    .query(async ({ ctx, input }) => {
      const { data, error } = await ctx.supabase
        .from('workflow_queries')
        .select('*')
        .eq('id', input.id)
        .single();

      if (error) {
        if (error.code === 'PGRST116') {
          throw new TRPCError({
            code: 'NOT_FOUND',
            message: 'Query not found',
          });
        }
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        });
      }

      return {
        query: data,
      };
    }),

  // Create query
  create: protectedProcedure
    .input(
      z.object({
        workflowId: z.string().uuid(),
        queryName: z.string().min(1).max(100),
        description: z.string().optional(),
        returnType: z.record(z.any()).optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      // Check if query name already exists for this workflow
      const { data: existing } = await ctx.supabase
        .from('workflow_queries')
        .select('id')
        .eq('workflow_id', input.workflowId)
        .eq('query_name', input.queryName)
        .single();

      if (existing) {
        throw new TRPCError({
          code: 'CONFLICT',
          message: `Query '${input.queryName}' already exists for this workflow`,
        });
      }

      // Create query
      const { data, error } = await ctx.supabase
        .from('workflow_queries')
        .insert({
          workflow_id: input.workflowId,
          query_name: input.queryName,
          description: input.description,
          return_type: input.returnType || null,
          auto_generated: false,
          created_by: ctx.user.id,
        })
        .select()
        .single();

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        });
      }

      return {
        query: data,
      };
    }),

  // Update query
  update: protectedProcedure
    .input(
      z.object({
        id: z.string().uuid(),
        queryName: z.string().min(1).max(100).optional(),
        description: z.string().optional(),
        returnType: z.record(z.any()).optional(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      const { id, ...updates } = input;

      // Check if this is auto-generated (can't be modified)
      const { data: query } = await ctx.supabase
        .from('workflow_queries')
        .select('auto_generated, workflow_id')
        .eq('id', id)
        .single();

      if (query?.auto_generated) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'Cannot modify auto-generated query handlers',
        });
      }

      // If updating query name, validate uniqueness
      if (updates.queryName && query) {
        const { data: existing } = await ctx.supabase
          .from('workflow_queries')
          .select('id')
          .eq('workflow_id', query.workflow_id)
          .eq('query_name', updates.queryName)
          .neq('id', id)
          .single();

        if (existing) {
          throw new TRPCError({
            code: 'CONFLICT',
            message: `Query '${updates.queryName}' already exists for this workflow`,
          });
        }
      }

      const { data, error } = await ctx.supabase
        .from('workflow_queries')
        .update({
          query_name: updates.queryName,
          description: updates.description,
          return_type: updates.returnType,
          updated_at: new Date().toISOString(),
        })
        .eq('id', id)
        .select()
        .single();

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        });
      }

      return {
        query: data,
      };
    }),

  // Delete query
  delete: protectedProcedure
    .input(
      z.object({
        id: z.string().uuid(),
      })
    )
    .mutation(async ({ ctx, input }) => {
      // Check if this is auto-generated (can't be deleted directly)
      const { data: query } = await ctx.supabase
        .from('workflow_queries')
        .select('auto_generated')
        .eq('id', input.id)
        .single();

      if (query?.auto_generated) {
        throw new TRPCError({
          code: 'BAD_REQUEST',
          message: 'Cannot delete auto-generated query handlers. Delete the associated work queue instead.',
        });
      }

      const { error } = await ctx.supabase
        .from('workflow_queries')
        .delete()
        .eq('id', input.id);

      if (error) {
        throw new TRPCError({
          code: 'INTERNAL_SERVER_ERROR',
          message: error.message,
        });
      }

      return {
        success: true,
      };
    }),
});

