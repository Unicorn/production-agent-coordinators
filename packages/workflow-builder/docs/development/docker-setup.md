# Docker Development Setup

Complete guide for running the development environment with Docker.

## Overview

We use a **hybrid approach**:
- **Infrastructure in Docker**: Kong, Temporal (via docker-compose)
- **Supabase via CLI**: Managed by Supabase CLI (handles migrations automatically)
- **Next.js locally**: Runs on your machine for fast hot reload

This gives you:
- ✅ Single command to start infrastructure
- ✅ Fast iteration on Next.js code
- ✅ Easy debugging (no container exec needed)
- ✅ Consistent environment across team

## Quick Start

### Option 1: Start Everything (Recommended for First Time)

```bash
cd packages/workflow-builder
./scripts/start-all.sh
```

This will:
1. Start Kong and Temporal (Docker)
2. Start Supabase (CLI)
3. Create/update `.env.local`
4. Optionally start Next.js

### Option 2: Start Infrastructure Only

```bash
cd packages/workflow-builder
./scripts/start-infrastructure.sh
```

Then manually:
```bash
# Start Supabase
supabase start

# Start Next.js
yarn dev
```

## Services

### Kong API Gateway
- **Gateway**: http://localhost:8000
- **Admin API**: http://localhost:8001
- **Note**: Kong Manager (Admin GUI) requires Kong Enterprise license and is not included

### Temporal
- **gRPC**: localhost:7233
- **Web UI**: http://localhost:8080

### Supabase
- **API**: http://localhost:54321
- **Studio**: http://localhost:54323
- **Database**: localhost:54322

### Next.js App
- **App**: http://localhost:3010

## Docker Compose

The infrastructure services are defined in `docker-compose.dev.yml`:

```bash
# Start services
docker-compose -f docker-compose.dev.yml up -d

# View logs
docker-compose -f docker-compose.dev.yml logs -f

# Stop services
docker-compose -f docker-compose.dev.yml down

# Stop and remove volumes (clean slate)
docker-compose -f docker-compose.dev.yml down -v
```

## Environment Variables

After running `start-all.sh`, your `.env.local` will be configured with:

```env
# Supabase (from `supabase start`)
NEXT_PUBLIC_SUPABASE_URL=http://localhost:54321
NEXT_PUBLIC_SUPABASE_ANON_KEY=<auto-generated>
SUPABASE_SERVICE_ROLE_KEY=<auto-generated>

# Database
DATABASE_URL=postgresql://postgres:postgres@localhost:54322/postgres

# Temporal
TEMPORAL_ADDRESS=localhost:7233
TEMPORAL_NAMESPACE=default

# Kong
KONG_ADMIN_URL=http://localhost:8001
KONG_GATEWAY_URL=http://localhost:8000
KONG_ADMIN_API_KEY=

# App
NEXT_PUBLIC_APP_URL=http://localhost:3010
WORKFLOW_API_BASE_URL=http://localhost:3010/api/workflows
NODE_ENV=development
```

## Managing Services

### Stop Next.js
If Next.js is running and you want to restart it:
```bash
./scripts/stop-nextjs.sh
```

### Stop Infrastructure
```bash
./scripts/stop-infrastructure.sh
```

### Stop Supabase
```bash
supabase stop
```

## Troubleshooting

### Services won't start
```bash
# Check Docker is running
docker ps

# Check for port conflicts
lsof -i :8000  # Kong
lsof -i :7233  # Temporal
lsof -i :54321 # Supabase
```

### Reset everything
```bash
# Stop and remove Docker services
docker-compose -f docker-compose.dev.yml down -v

# Stop Supabase
supabase stop

# Remove Supabase volumes (optional, nuclear option)
docker volume ls | grep supabase | awk '{print $2}' | xargs docker volume rm
```

### Kong not accessible
```bash
# Check Kong health
curl http://localhost:8001/status

# View Kong logs
docker logs workflow-builder-kong
```

### Temporal not accessible
```bash
# Check Temporal health
curl http://localhost:8080

# View Temporal logs
docker logs workflow-builder-temporal
```

## Why This Approach?

### Pros
- **Fast iteration**: Next.js hot reload works instantly
- **Easy debugging**: No need to exec into containers
- **Simple setup**: One script to start everything
- **Flexible**: Can start/stop services independently
- **Production-like**: Infrastructure matches production setup

### Cons
- **Requires Node.js locally**: Can't run everything in Docker
- **Port management**: Need to ensure no conflicts

## Alternative: Full Docker (Not Recommended)

If you want everything in Docker (including Next.js), you can:

1. Create a Dockerfile for the Next.js app
2. Add it to docker-compose.dev.yml
3. Mount source code as volume

**Why we don't do this:**
- Slower hot reload (file watching across Docker volumes)
- Harder debugging (need to exec into container)
- More complex setup
- Resource intensive

## Production

For production, we use:
- Separate Docker Compose for each service
- Kubernetes (future)
- Managed services (Supabase Cloud, Temporal Cloud)

The development setup mirrors production architecture but runs locally.

